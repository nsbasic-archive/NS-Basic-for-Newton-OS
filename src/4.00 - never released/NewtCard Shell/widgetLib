/* This file defines the widgets (Buttons and Fields)Slots in this file form proto defs for the widgets.Contents: This slot contains the name of the field that is the value of the widgetUpdateMethod: If a widget has this, then the  widget is one in which the value the user's edits is not accessable to the user by  referencing a slot in the frame. An example is the scroller widget, in which the  text the user is editing is really in a VBO accessable only to protoTXview.    Widgets that are this way have two methods defined:  updateField(text) sets the value in the frame and the view,  getText() copies the value from the view to the frame and returns it.*/defconst('kWidgetLib, {	// this one is a special case: it puts up a simple window	pt_userView: {goto: NIL, gosub: NIL, drawing: [], type: 'ignore, visible: TRUE},	app:			{_proto: {}, type: 'ignore, expert: kExpertExpert, visible: TRUE},	azTabs:	{item: "azTabs",					_proto: protoAZtabs,					goto: nil, gosub: nil,					viewBounds: SetBounds(100, 70, 325, 88),					viewFlags: vClickable,					viewJustify: vjCenterH+vjCenterV,					visible: TRUE,					pickLetterScript: func(letter) begin						self.text:=letter;						executor:userClickAction(NIL,self) 						end,					contents: 'text,					type: 'button, expert: kExpertExpert},	azVertTabs:		{item: "azVertTabs",						_proto: protoAZVertTabs,						goto: nil, gosub: nil,						viewBounds: SetBounds(100, 90, 125, 226),						viewFlags: vClickable,						viewJustify: vjCenterH+vjCenterV,						visible: TRUE,						pickLetterScript: func(letter) begin							self.text:=letter;							executor:userClickAction(NIL,self) 							end,						contents: 'text,						type: 'button, expert: kExpertExpert},  	checkbox:	{item: "checkbox",						_proto: protoCheckBox, 						viewValue: NIL,						text: "Checkbox", 						viewBounds: {left: 100, right: 200, top:100, bottom: 120},						viewFlags: vClickable,          	viewFont: ROM_fontSystem10,          	viewFormat: nil,          	visible: TRUE, 						updateMethod: 'updateField,						updateField: func(x) begin							self.viewValue:=x;							:updateBitMap();							end,						getText: func() viewValue,  					contents: 'viewValue,						viewClickScript: func(unit) begin 							inherited:?viewClickScript(unit);    				  executor:userClickAction(unit,self)     				  end,    				type: 'button, expert: kExpertScript},	closeBox:	{item: "closeBox",						_proto: protoCloseBox,						declareSelf: 'base,						viewFlags: vClickable + vReadOnly,						visible: TRUE,						buttonClickScript: func() executor:userClickAction(NIL,self),						type: 'button, expert: kExpertExpert},	datePicker: {item: "datePicker",						_proto: protoDatePicker, 						viewBounds: {left: 100, right: 220, top: 120, bottom: 200},						viewFlags: vClickable,						selectedDates: [time()],						viewFormat: nil,						visible: TRUE,						dateChanged: func(dates) begin							local context:=self._parent;							if NOT hasSlot(context, 'windowSpec) then context:=context._parent;							executor:userClickAction(NIL,context) 							end,						updateMethod: 'updateField,						updateField: func(x) begin							self.selectedDates:=x;							:refresh();							end,						getText: func() selectedDates,						contents: 'selectedDates,						type: 'field, expert: kExpertScript},			  							digitalClock: {item: "digitalClock",						_proto: protoDigitalClock,			  						 						viewBounds: {left: 1, right: 119, top: 101, bottom: 128},						time: time(),						viewFlags: vClickable,						visible: TRUE,						timeChanged: func() begin							local context:=self._parent;							if NOT hasSlot(context, 'windowSpec) then context:=context._parent;							executor:userClickAction(NIL,context) end,						contents: 'time,						type: 'field, expert: kExpertScript},   				  						 	draw:		 	{item: "draw",						drawing: nil,						drawDrawing: func() begin							if debug then print("drawDrawing");							:lockScreen(TRUE);							:drawShape(drawing, styleFrame);							:lockScreen(NIL);							end,						viewClass: clEditView, 						viewBounds: {Left:1, right: 100, top:1, bottom: 100},						viewDrawScript: func() 							if drawing and length(drawing)>0 then :drawDrawing(),						viewFlags: vClickable+vGesturesAllowed+vShapesAllowed,						viewFormat: vfFillWhite+vfFrameBlack+vfPen(1)+vfLinesLtGray,						viewLineSpacing: 32,						viewChildren: clone([]),						viewFont: simpleFont18,						viewAddChildScript: func(newOne) begin							:doAda(func() _rf:userClickAction(NIL,self), '[], 0);							NIL end,						visible: TRUE,						updateMethod: 'updateField,						updateField: func(x) begin 							self.viewChildren:=x; 							:redoChildren();							refreshviews();							end,						getText: func() self.viewChildren,						contents: 'viewChildren,						type: 'field, expert: kExpertScript},   				  			     	// this one doesn't work: it may be the viewChildren slot for the checkbox	floatNGo:	 {item: "floatNGo",						_proto: protofloatNGo,						viewBounds: {left: 50, right: 100, top: 6, bottom: 40},						text: "FloatNGo",						viewChildren: [{_proto: protoStaticText}],						visible: TRUE,						type: 'ignore, expert: kExpertExpert},   				  	glance:	 {item: "glance",					_proto: protoGlance,					viewBounds: {left: 100, right: 200, top: 60, bottom: 75},					visible: TRUE,					text: "Glance",					type: 'ignore, expert: kExpertExpert},	gauge:   {item: "gauge",					viewClass: clGaugeView,					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				executor:userClickAction(unit,self)     				end,					viewValue:50,					viewBounds: {left: 100, right: 200, top: 90, bottom: 100},					viewFlags: vReadOnly+vClickable,					visible: TRUE,					gaugedrawlimits: TRUE,					minValue: 0,					maxValue: 100,					viewSetupFormScript: func() NIL,					contents: 'viewValue,					type: 'field, expert: kExpertExpert},   				  	labelInput:	 {item: "labelInput",						_proto: protoLabelInputLine,						viewFlags: vReadOnly+vClickable,						viewBounds: {left:100, right: 240, top: 40, bottom: 60},						currLabelCommand: 0,						entryFlags: vVisible+vClickable+vGesturesAllowed+vCharsAllowed+vNumbersAllowed,						labelfont: ROM_fontSystem9Bold,						labelCommands: ["one","two"],						label: "Label",						text: "",						viewValue: 0,						textSetup: func() begin							//setup:=true; //this was intented to stop textChanged from happening - is it needed?							text end,						setup: NIL,						visible: TRUE,						labelActionScript: func(x) begin 							self._parent.text:=labelCommands[x]; 							nil end,						textChanged: func() begin							print("LabelInput:textChanged");							print(setup);							if setup then setup:=NIL											 else executor:userClickAction(NIL,self._parent) 							end,						updateMethod: 'updateField,						updateField: func(x) begin 								self.text:=x; 								:updateText(x) 							 end,						getText: func() begin text end,						contents: 'text,						type: 'field, expert: kExpertExpert},	labelPicker: {item: "labelPicker",						_proto: protoLabelPicker,						viewBounds: {left:100, right: 240, top: 40, bottom: 60},						checkCurrentItem: TRUE,						labelCommands: ["One","Two","Three"],						text: "labelPicker",						viewValue: 0,						visible: TRUE,						textSetup: func() begin labelCommands[viewValue] end,						labelActionScript: func(x) begin							self.viewValue:=x;							executor:userClickAction(NIL,self); 							NIL end,						updateMethod: 'updateField,						updateField: func(x) begin 								self.viewValue:=x; 								if x then :updateText(labelCommands[viewValue]) 							 end,						getText: func() begin viewValue end,						contents: 'viewValue,						type: 'field, expert: kExpertExpert},	LargeCloseBox: {item: "largeCloseBox",							_proto: protoLargeCloseBox,							declareSelf: 'base,							viewFlags: vClickable + vReadOnly,							visible: TRUE,							buttonClickScript: func() executor:userClickAction(NIL,self),							type: 'button, expert: kExpertExpert},				  							month:	 {item: "month",					viewClass: clMonthView,					viewBounds: {left: 100, right: 200, top: 120, bottom: 180},					viewFlags: vClickable,					viewFormat: vfFillWhite,					visible: TRUE,					selectedDates: [time()],					labelFont: ROM_fontsystem9Bold,					dateFont: ROM_fontSystem9,					monthChangedScript: func() executor:userClickAction(NIL,self),					contents: 'selectedDates,					type: 'field, expert: kExpertExpert},	newSetClock: {item: "newSetClock",						_proto:  protoNewSetClock,						viewBounds: {left: 1, right: 64, top:1, bottom: 64},						viewFlags: vClickable,						visible: TRUE,						minutes: date(time()).minute, 						hours: date(time()).hour,						time: time(),						timeChanged: func() begin 							self.hours:=hours;							self.minutes:=minutes;							:refresh();							executor:userClickAction(NIL,self) 							end,						updateMethod: 'updateField,						updateField: func(x) begin							self.time:=x;							:refresh();							end,						getText: func() time,						contents: 'time,						type: 'field, expert: kExpertScript},    				  				      	numberPicker: {item: "numberPicker",						_proto: protoNumberPicker,						viewBounds: {left: 1, right: 200, top: 131, bottom: 160},						viewFlags: 0,						visible: TRUE,						minValue: 0,						maxValue: 9999999,						Value: 0,						showLeadingZeros: TRUE,						clickDone: func() begin							local context:=self._parent;							if NOT hasSlot(context, 'windowSpec) then context:=context._parent;							executor:userClickAction(NIL,context) end,						contents: 'value,						type: 'field, expert: kExpertScript},    				  				   						  	paragraph: {item: "paragraph",					drawing: nil,					drawDrawing: func() begin						if debug then print("doDrawing");						:lockScreen(TRUE);						:drawShape(drawing, styleFrame);						:lockScreen(NIL);						refreshviews();						end,					viewClass: clParagraphView,					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				executor:userClickAction(unit,self)     				end,					viewBounds: {Left:1, right: 100, top:150, bottom: 240},					viewDrawScript: func() if drawing and length(drawing)>0 then :drawDrawing(),					viewFlags: vReadOnly+vClickable,					viewFormat: vfFillWhite+vfFrameBlack+vfPen(1),					viewJustify: vjLeftH,					viewLineSpacing: 16,					text: "paragraph",					viewFont: simpleFont12,					visible: TRUE,					contents: 'text,					type: 'field, expert: kExpertExpert},	//peoplePicker: {_proto: protoPeoplePicker},	pictureButton: {item: "pictureButton",							_proto: protoPictureButton,							icon: NIL,							viewBounds: {Left:1, right: 32, top:1, bottom: 32},							viewFormat: vfFrameBlack + vfpen(2) + vfround(4),							viewFlags: vClickable+vReadOnly,							visible: TRUE,							buttonClickScript: func() executor:userClickAction(NIL,self),							type: 'button, expert: kExpertScript}, 			  				   						      				  				   						   				  				   	picker:		{item: "picker",						_proto: protoPicker,						Bounds: {left:1, right: 95, top:120, bottom: 140},						pickItems: [{item: "Picker", pickable: true, mark: kCheckMarkChar},							'pickseparator,"Two","Three"],						viewFormat: vfFrameBlack+vfFillWhite+vfPen(2)+vfround(4),						visible: TRUE,						pickActionScript: func(x) begin 							viewvalue:=x;							executor:userClickAction(NIL,self) 							end,						contents: 'viewValue,						type: 'ignore, expert: kExpertScript},				  				       				  				    	popupButton:	 {item: "popupButton",						_proto: protoPopupButton,						viewFlags: vClickable+vReadOnly,						viewBounds: {Left:100, right: 160, top:1, bottom: 16},						text: "  Popup",						popup: ["one","two",'pickSeparator,"none"],						pickActionScript: func(x) begin							viewValue:=x;							executor:userClickAction(NIL,self); 							inherited:pickActionScript(x) end,						viewValue: 0,						viewFont: ROM_fontsystem9Bold,						viewJustify: vjcenterv+vjcenterh+onelineonly,						viewFormat: vfFrameBlack + vfpen(2) + vfround(4),						visible: TRUE,						contents: 'viewValue,						type: 'button, expert: kExpertScript}, 			  				   						  	rCheckbox: {item: "right checkbox",					_proto: protoRCheckBox,					viewValue: NIL,					text: "right checkbox",					viewBounds: {left: 1, right: 105, top:100, bottom: 120},					indent: 6,					viewFlags: vClickable,					viewFont: ROM_fontSystem10,          viewFormat: nil,          visible: TRUE,					viewSetupFormScript: func() begin indent:=viewBounds.right-10; end, 					updateMethod: 'updateField,					updateField: func(x) begin						self.viewValue:=x;						:updateBitMap();						end,					getText: func() viewValue,  				contents: 'viewValue,					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				executor:userClickAction(unit,self)     				end,    			type: 'button, expert: kExpertScript},   	scroller: {item: "scroller",					_proto: {},					text: "text",					contents: 'text,					updateMethod: 'updateField,					boxTitle: "BoxTitle",					editOK: TRUE,					viewBounds: {Left:110, right: 220, top:1, bottom: 100},    			visible: TRUE,					type: 'field, expert: kExpertScript},  				  						     				  						 	setClock: {item: "setClock",					_proto: protoSetClock,					viewBounds: {left: 1, right: 64, top:1, bottom: 64},					viewFlags: vClickable+vStrokesAllowed,					visible: TRUE,					minutes: date(time()).minute, 					hours: date(time()).hour,					time: {hours: date(time()).hour, minutes: date(time()).minute},					timeChanged: func() begin 						self.time:={hours: hours, minutes: minutes};						:dirty();						executor:userClickAction(NIL,self) 						end,					updateMethod: 'updateField,					updateField: func(x) begin						print('updateFieldSetClock);						print(x);						self.minutes:=x.minutes;						self.hours:=x.hours;						time:={minutes: minutes, hours: hours};						:dirty();						end,					getText: func() {minutes: minutes, hours: hours},					contents: 'time,					type: 'field, expert: kExpertExpert},  				     				 						 				  						 	slider:  {item: "slider",					_proto: protoSlider, viewValue:50,					minValue: 0,					maxValue: 100,					gaugeDrawLimits: TRUE,					viewFlags: vClickable,					viewBounds: {left: 100, right: 200, top: 90, bottom: 100},					viewSetupFormScript: func() nil,					visible: TRUE,					changedSlider: func() executor:userClickAction(NIL,self),					contents: 'viewValue,					type: 'field, expert: kExpertScript},	status:	 {_proto: protoStatus, 						type: 'ignore, 						visible: TRUE, 						expert: kExpertExpert},	text:	   {item: "text",					viewClass: clParagraphView,					viewBounds: {Left:110, right: 220, top:1, bottom: 100},					viewFlags: vClickable+vGesturesAllowed+vCharsAllowed+vPunctuationAllowed+vNumbersAllowed,					viewFormat: vfFillWhite+vfFrameBlack+vfPen(1)+vfLinesGray,					viewJustify: vjLeftH,					viewLineSpacing: 16,					visible: TRUE,					text: "Text Box",					contents: 'text,					viewFont: userFont18,					tabs: [20,40,60,80,120,140,160,180],					viewChangedScript: func(slot,view) executor:userClickAction(NIL,self),					type: 'field, expert: kExpertScript},    				  				         		 	textButton: {item: "textButton",						_proto: protoTextButton,						GOTO: nil,						GOSUB: nil,						viewBounds: {Left:1, right: 60, top:1, bottom: 16},						viewFlags: vClickable+vReadOnly,						text: "Button",						contents: 'text,						viewFont: ROM_fontsystem9Bold,						viewFormat: vfFrameBlack + vfpen(2) + vfround(4),						visible: TRUE,						buttonClickScript: func() executor:userClickAction(NIL,self),						type: 'button, expert: kExpertScript}, 			  				   						  	textList: {item: "textList",					_proto: protoTextList,					viewBounds: {top: 10, left: 10, right: 100, bottom: 100},					visible: TRUE,					useScrollers: TRUE,					useMultipleSelections: NIL,					listItems: ["one","two","three"],					viewFormat: vfFrameBlack + vfpen(1) + vfFillWhite,					checkType: func(x) begin						if useMultipleSelections then begin							if classOf(x)<>'array then x:=[];							end;						else begin							if x and classOf(x)<>'int then x:=nil;							end;							x						end,									buttonClickScript: func(i) begin						inherited:?buttonClickScript(i);						if useMultipleSelections 							then self.viewValue:=selectedItems							else self.viewValue:=selection;					 						executor:userClickAction(NIL,self) 						end,					viewSetupDoneScript: func() begin						self.viewValue:=selection:=selectedItems:=:checkType(viewValue);						:setupList();:redochildren() 						end,					updateMethod: 'updateField,					updateField: func(x) begin 						x:=:checkType(x);						if useMultipleSelections 							then self.viewValue:=selectedItems:=x							else self.viewValue:=selection:=x;						:setupList(); :redoChildren();						end,					getText: func() begin						if useMultipleSelections 							then self.viewValue:=selectedItems							else self.viewValue:=selection;							viewValue;							end,					viewValue: 0,					contents: 'viewValue,					scrollAmounts: [1,5,20],					type: 'field, expert: kExpertExpert},  title:	 {item: "title",  				_proto: protoStaticText,   				viewBounds: {Left:1, right: 60, top:20, bottom: 35},					viewClickScript: func(unit) begin 						inherited:?viewClickScript(unit);    				 executor:userClickAction(unit,self)     				 end,  				viewJustify: vjLeftH,  				viewFont: ROM_fontSystem12Bold,  				viewFlags: vReadOnly+vClickable,  				text: "title",  				viewFormat: nil,  				visible: TRUE,  				contents: 'none,   				type: 'field, expert: kExpertScript},   });defconst('homePathP, strPos(home, "NewtCard Shell", 0));defconst('homePath, if homePathP then substr(home, 0, homePathP) else home);OpenResFile(homePath & "Unit- VisualDesigner:vResource.rsrc");call func() begin	local icons := {};	local skip := ['app, 'status, 'glance, 'floatNGo, 'picker, 'pt_userView,];	foreach slot, value in kWidgetLib do begin		if not LSearch(skip, slot, 0, '|=|, nil) then			icons.(slot) := GetPictAsBits(SPrintObject(slot), nil);		end;	DefConst('kWidgetIcons, icons);end with ();CloseResFile();